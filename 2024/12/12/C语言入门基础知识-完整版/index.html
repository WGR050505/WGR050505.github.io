<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>万人迷的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="title: C语言入门基础知识[完整版]date: 2024-12-12 22:22:52tags:C 目录一、数据类型和表达式1.基本类型2.构造类型1）数组类型2）结构体类型3）共用体类型3.常量4.运算表达式1）算术运算表达式：2）关系运算表达式：3）逻辑运算符：4）位运算符：二、C语言的语句1.表达式语句2.函数调用语句3.控制语句1）条件判断语句：2）循环执行语句：3）转向语句：4.复">
<meta property="og:type" content="article">
<meta property="og:title" content="万人迷的博客">
<meta property="og:url" content="http://example.com/2024/12/12/C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%AE%8C%E6%95%B4%E7%89%88/index.html">
<meta property="og:site_name" content="万人迷的博客">
<meta property="og:description" content="title: C语言入门基础知识[完整版]date: 2024-12-12 22:22:52tags:C 目录一、数据类型和表达式1.基本类型2.构造类型1）数组类型2）结构体类型3）共用体类型3.常量4.运算表达式1）算术运算表达式：2）关系运算表达式：3）逻辑运算符：4）位运算符：二、C语言的语句1.表达式语句2.函数调用语句3.控制语句1）条件判断语句：2）循环执行语句：3）转向语句：4.复">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-12-12T14:22:52.784Z">
<meta property="article:modified_time" content="2024-12-12T14:36:23.589Z">
<meta property="article:author" content="Mr万">
<meta property="article:tag" content="安徽大学，男大">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="万人迷的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">万人迷的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">WGR</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-C语言入门基础知识-完整版" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/12/12/C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%AE%8C%E6%95%B4%E7%89%88/" class="article-date">
  <time class="dt-published" datetime="2024-12-12T14:22:52.784Z" itemprop="datePublished">2024-12-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>title: C语言入门基础知识[完整版]<br>date: 2024-12-12 22:22:52<br>tags:C</p>
<p>目录<br>一、数据类型和表达式<br>1.基本类型<br>2.构造类型<br>1）数组类型<br>2）<a href="#jiegou">结构体类型</a><br>3）<a href="#lianhe">共用体类型</a><br>3.常量<br>4.运算表达式<br>1）算术运算表达式：<br>2）关系运算表达式：<br>3）逻辑运算符：<br>4）位运算符：<br>二、C语言的语句<br>1.表达式语句<br>2.函数调用语句<br>3.控制语句<br>1）条件判断语句：<br>2）循环执行语句：<br>3）转向语句：<br>4.复合语句<br>5.空语句<br>6.案例<br>1）海伦公式<br>2）一元二次方程<br>三、函数<br>1.函数的概念<br>2.函数的定义方式<br>3.函数的参数<br>4.函数的返回值<br>5.函数的调用<br>6.全局变量与局部变量<br>1）全局变量<br>2）局部变量<br>7.静态变量与寄存器变量<br>1）静态变量<br>2）寄存器变量<br>8.预处理命令<br>1）宏定义<br>2）文件包含<br>3）条件编译<br>四、指针<br>1.变量的指针&amp;指针变量<br>1）指针变量的定义<br>2）指针的操作<br>2.数组的指针&amp;指针数组<br>1）数组的指针<br>2）指针数组<br>3.字符串的指针<br>4.函数的指针&amp;指针型函数<br>1）函数的指针<br>2）指针型函数<br>5.指向指针的指针<br>五、结构体和共用体<br>1.结构体<br>1）结构体的定义<br>2）结构体的用法<br>2.共用体（联合体）<br>1）共用体的定义<br>2）共用体的用法<br>3.枚举<br>1）枚举的定义<br>2）枚举的用法<br>4.动态内存分配<br>1）malloc<br>2）calloc<br>3）realloc<br>4）free<br>5.位域<br>六、文件操作<br>1.文件的概念<br>2.文件指针<br>3.操作文件的函数<br>1）打开与关闭<br>2）文件读写<br>3）文件定位<br>4）文件检测<br>5）文件操作示例<br>一、数据类型和表达式<br>C语言中二进制数、八进制数和十六进制数的表示:</p>
<p>二进制：二进制由 0 和 1 两个数字组成，使用时必须以0b或0B（不区分大小写）开头。例如：0b101、0B001<br>注意：标准的C语言并不支持二进制写法，有些编译器自己进行了扩展，才会支持二进制数字<br>八进制：八进制由 0<del>7 八个数字组成，使用时必须以0开头（注意是数字 0，不是字母 o），例如：015（十进制的13）、0177777（十进制的65535）<br>十六进制：十六进制由数字 0</del>9、字母 A<del>F 或 a</del>f（不区分大小写）组成，使用时必须以0x或0X（不区分大小写）开头，例如：0X2A（十进制的42）、0xffff（十进制的65535）<br>1.基本类型<br>整型(int)<br>字符型(char)<br>实型（浮点型）<br>单精度型(float)<br>双精度型(double)<br>枚举类型<br>下面是详细的类型说明：<br>类型	类型说明符	字节	数字范围<br>字符型	char	1	C字符集<br>基本整型	int	4	-32768<del>32767<br>短整型	short int	2	-32768</del>32767<br>长整型	long int	4	-214783648<del>-214783647<br>无符号整型	unsigned int	4	0</del>65535<br>无符号长整型	unsigned long	4	0<del>4294967295<br>单精度实型	float	4	10-38</del>1038<br>双精度实型	double	8	10-308~10-308<br>2.构造类型<br>1）数组类型<br>数组：按序排列的同类数据元素的集合</p>
<p>一维数组：类型说明符 数组名[数组长度];<br>二维&#x2F;多维数组：类型说明符 数组名[行数][列数]; 多维数组以此类推<br>字符数组：char 数组名[数组长度];C语言没有字符串类型，字符串通常用字符数组表示<br>数组定义：类型说明符 数组名[长度];<br>数组引用：<br>一维数组数组名[索引];     二维数组数组名[行索引][列索引];<br>注：索引都是从0开始<br>数组赋值：<br>1.在定义的时候赋初值：int a[10]&#x3D;{1,2,3,4,5,6,7,8,9,10};或int a[]&#x3D;{1,2,3,4,5,6,7,8,9,10};<br>2.先定义,再赋值：int a[10];a &#x3D; {1,2,3,4,5,6,7,8,9,10};<br>字符数组赋值：<br>1.char Hello[] &#x3D; {‘H’,’e’,’l’,’l’,’o’};<br>2.char Hello[] &#x3D; “Hello”;<br>注：字符数组第二种赋值方式比第一种方式多占一个字符，因为第二种方式会在字符数组中结尾添加一个\0作为字符串结束符</p>
<p>提示：数组赋值时，如果给定值数量小于数组长度，系统默认填充0</p>
<p>示例：</p>
<p>#include &lt;stdio.h&gt;</p>
<p>int main() {<br>    &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;一维数组&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>    int a[5] &#x3D; {1, 2}; &#x2F;&#x2F; a&#x3D;{1,2,0,0,0}<br>    int b[] &#x3D; {1, 2, 3, 4, 5};&#x2F;&#x2F; b&#x3D;{1,2,3,4,5}<br>    int c[10];&#x2F;&#x2F; 没有赋初始值系统会自动赋值一个无意义的数字，可以自行printf输出查看<br>    printf(“a第二个元素：%d\nb第一个元素：%d\n”, a[1], b[0]);</p>
<pre><code>//=====================二维数组===============
int aa[2][3] = &#123;1, 2, 3, 4, 5, 6&#125;;// C语言是按行编址，所以可以这样赋值
int bb[2][3] = &#123;
        &#123;1, 2, 3&#125;,
        &#123;4, 5, 6&#125;
&#125;;
//aa和bb这两个数组是相同的
printf(&quot;aa第1行第1列元素：%d\n&quot;, aa[0][0]);
printf(&quot;bb第1行第2列元素：%d\n&quot;, bb[0][1]);
//=====================字符串===============
char name[8] = &#123;&#39;x&#39;, &#39;i&#39;, &#39;a&#39;, &#39;o&#39;, &#39;m&#39;, &#39;i&#39;, &#39;n&#39;, &#39;g&#39;&#125;;
char name2[] = &quot;xiaohong&quot;;
printf(&quot;第一个名字：%s第二个名字：%s&quot;, name, name2);
return 0;
</code></pre>
<p>}</p>
<p>2）结构体类型<br>3）共用体类型<br>3.常量<br>C语言中常量的定义有两种方式，假如我们要定义一个int类型的常量TEMP，值为1：</p>
<p>预定义命令： #define TEMP &#x3D; 1<br>const关键字：const int TEMP &#x3D; 1<br>4.运算表达式<br>1）算术运算表达式：<br>加：+<br>减：-<br>乘：*<br>除：&#x2F;<br>取余：%<br>自增：++<br>自减：–<br>注意：自增和自减跟赋值运算结合的时候如果运算符在左边，会先进行自增或自减运算，请看下面例子：</p>
<p>void test1(){<br>int a &#x3D; 1;<br>int b &#x3D; ++a; &#x2F;&#x2F;结果是b&#x3D;2<br>}</p>
<p>void test2(){<br>int a &#x3D; 1;<br>int b &#x3D; a++; &#x2F;&#x2F;结果是b&#x3D;1<br>}</p>
<p>2）关系运算表达式：<br>等于：&#x3D;&#x3D;<br>大于：&gt;<br>大于等于：&gt;&#x3D;<br>小于：&lt;<br>小于等于：&lt;&#x3D;<br>不等于：!&#x3D;<br>3）逻辑运算符：<br>C语言中非0为真</p>
<p>与：&amp;&amp;<br>或：||<br>非：!<br>4）位运算符：<br>位与：&amp;<br>对每一位进行逻辑与运算，0表示假，1表示真：0011 &amp; 1111 &#x3D; 0011<br>位或：|<br>对每一位进行逻辑或运算，0表示假，1表示真：0011 | 1111 &#x3D;1111<br>位非：~<br>对每一位进行逻辑非运算，0表示假，1表示真：~1111 &#x3D;0000<br>位异或：^<br>对每一位进行逻辑异或运算，0表示假，1表示真：0011 ^ 1111 &#x3D;1100<br>左移：&lt;&lt;<br>高位溢出丢弃，低位不足补0：01100100 &lt;&lt; 2 &#x3D; 10010000<br>右移：&gt;&gt;<br>正数：高位补0，低位溢出舍去：01111111 &gt;&gt; 4 &#x3D; 00000111<br>负数：高位补1，低位溢出舍去：11111111 &gt;&gt; 4 &#x3D; 11111111<br>二、C语言的语句<br>1.表达式语句<br>定义：由表达式和分号组成的语句：x + y &#x3D; z;</p>
<p>2.函数调用语句<br>定义：函数名、实际参数和分号组成：函数名(参数);</p>
<p>3.控制语句<br>1）条件判断语句：<br>if语句：单条件判断语句<br>&#x2F;&#x2F; 用法<br>if (条件表达式){<br>    &#x2F;&#x2F; 条件满足<br>    要执行的语句<br>}</p>
<p>if…else…语句：条件分支语句<br>&#x2F;&#x2F; 用法<br>if (条件表达式){<br>    &#x2F;&#x2F; 条件满足<br>    要执行的语句<br>}else{<br>    &#x2F;&#x2F; 条件不满足<br>    要执行的语句<br>}</p>
<p>if…else if…else…语句：多条件分支语句<br>&#x2F;&#x2F; 用法<br>if (条件表达式1){<br>    &#x2F;&#x2F; 满足条件表达式1<br>    要执行的语句;<br>}else if (条件表达式2) {<br>    &#x2F;&#x2F; 满足条件表达式2<br>    要执行的语句;<br>}else if (条件表达式3) {<br>    &#x2F;&#x2F; 满足条件表达式3<br>    要执行的语句;<br>}</p>
<p>…</p>
<p>else if (条件表达式n) {<br>    &#x2F;&#x2F; 满足条件表达式n<br>    要执行的语句;<br>}else{<br>    &#x2F;&#x2F; 所有条件表达式都不满足<br>    要执行的语句;<br>}</p>
<p>switch语句：开关语句，一般配合case关键字使用<br>switch(表达式)<br>{</p>
<pre><code>case 常量1： 
    // 如果表达式的值等于常量1，执行下面的语句1
    语句1 ;
    break;

case 常量2： 
    // 如果表达式的值等于常量2，执行下面的语句2
    语句2;
    break;

    ...

case 常量n:
    // 如果表达式的值等于常量n，执行下面的语句n
    语句n;
    break;

default:
    // 默认执行的语句，如果没有通过上面的开关语句退出，就会执行下面的语句n+1
    语句n+1;
    //break; // default可以省略break;因为它本身就是最后执行，执行完就会退出开关语句。
</code></pre>
<p>}</p>
<p>注：switch语句如果没有break会一直向下执行直到结束。</p>
<p>2）循环执行语句：<br>for语句<br>结构：<br>for (表达式1;表达式2;表达式3){<br>语句;<br>}<br>循环逻辑：<br>step1：先执行表达式1<br>step2：然后执行表达式2，<br>step3：如果step2结果为真，执行语句，否则退出循环<br>step4：如果step3没有退出循环，则执行表达式3<br>step5：重复执行step2-step4直至循环退出</p>
<p>&#x2F;&#x2F;用法<br>for (循环变量赋初值;循环条件;循环变量增量){<br>    执行语句;<br>}<br>while语句<br>条件循环语句，当满足循环条件的情况下循环执行</p>
<p>&#x2F;&#x2F;用法<br>while (循环条件){<br>    执行语句;<br>}</p>
<p>do while语句<br>与while循环的区别：do…while会先执行一遍循环体里面的语句，再进行条件判断，也就是说，do…while至少会执行一次循环体中的语句</p>
<p>&#x2F;&#x2F;用法<br>do{<br>    执行语句;<br>}while (循环条件);</p>
<p>3）转向语句：<br>continue：continue语句一般用于循环结构中，作用是跳过当次循环，当循环语句执行到continue时，不会继续向下执行，会跳过当次循环，直接执行下一次循环。<br>break：中断语句，一般用于循环结构中，作用是终止循环，当执行到break语句时，会立即退出循环。<br>return：跳出函数语句，用于跳出函数并返回一个值。<br>goto：强制转向语句（不推荐使用）<br>&#x2F;&#x2F;用法<br>int main(){<br>    int a&#x3D;1;<br>    int b&#x3D;5;<br>    loop: if (a&lt;b){<br>        printf(“%d\n”,a);<br>        a++;<br>        goto loop;<br>    }<br>    return 0;<br>}</p>
<p>输出结果：<br>说明：goto语句一般用于跟if语句结合形成循环结构，需要先定义一个标志符（loop），表示goto转向到哪个地方。</p>
<p>4.复合语句<br>定义：将多个语句用大括号括起来组成一个复合语句</p>
<p>{<br>    int a &#x3D; 1;<br>    a++;<br>    int b &#x3D; a + 1;<br>}</p>
<p>5.空语句<br>定义：只有分号组成的语句称为空语句</p>
<p>;<br>1<br>6.案例<br>1）海伦公式<br>根据三角形的三条边求出面积：S&#x3D;p ( p − a ) ( p − b ) ( p − c ) \sqrt{p(p-a)(p-b)(p-c)}<br>p(p−a)(p−b)(p−c)<br>​</p>
<p>S:面积    p:周长的1&#x2F;2    a,b,c:三角形的三条边长</p>
<p>#include “stdio.h”<br>#include “math.h”</p>
<p>int main(){<br>    float a;<br>    float b;<br>    float c;<br>    float area;<br>    float p;<br>    printf(“请输入构成三角形的三条边的长度：”);<br>    scanf(“%f,%f,%f”, &amp;a, &amp;b, &amp;c);<br>    p &#x3D; (a+b+c)&#x2F;2;<br>    area &#x3D; sqrt(p*(p-a)<em>(p-b)</em>(p-c));<br>    printf(“三角形面积是：%f”,area);<br>    return 0;<br>}</p>
<p>2）一元二次方程<br>#include &lt;stdio.h&gt;<br>#include “math.h”</p>
<p>int main() {<br>    float a,b,c;<br>    float p,x1,x2;<br>    printf(“请输入一元二次方程的3个系数a,b,c：ax^2+bx+c&#x3D;0(a≠0)\n”);<br>    scanf(“%f,%f,%f”,&amp;a,&amp;b,&amp;c);<br>    p &#x3D; sqrt(b<em>b-4</em>a<em>c);<br>    x1 &#x3D; (-b+p)&#x2F;(2</em>a);<br>    x2 &#x3D; (-b-p)&#x2F;(2*a);<br>    printf(“方程的解为：x1&#x3D;%f,x2&#x3D;%f”,x1,x2);<br>    return 0;<br>}</p>
<p>三、函数<br>1.函数的概念<br>函数是实现了某种功能的代码块</p>
<p>库函数：由Ｃ系统提供，用户无须定义，也不必在程序中作类型说明，只需在程序前包含有该函数原型的头文件即可在程序中直接调用。<br>用户定义函数：由用户按需要写的函数。对于用户自定义函数，不仅要在程序中定义函数本身，而且在主调函数模块中还必须对该被调函数进行类型说明，然后才能使用。<br>2.函数的定义方式<br>无参函数：<br>类型标识符 函数名() {<br>    声明部分;<br>    语句;<br>}</p>
<p>有参函数：<br>类型标识符 函数名(形参1,形参2,形参3…形参n) {<br>    声明部分;<br>    语句;<br>}</p>
<p>示例：下面定义了两个函数，第一个HelloWorld是无参函数，功能是输出一个”Hello World!”字符串，第二个FindMax是有参函数，接收两个int类型的参数，返回两个数中最大的那个数<br>&#x2F;&#x2F;void HelloWorld();<br>&#x2F;&#x2F;int FindMax(int a,int b);<br>&#x2F;&#x2F;上面是对函数进行声明，函数的调用必须先定义，否则编译不通过，如果定义在调用函数之后，需要先声明</p>
<p>void HelloWorld() {<br>    printf(“Hello World!”);<br>}</p>
<p>int FindMax(int a, int b) {<br>    int max;<br>    max &#x3D; a &gt;&#x3D; b ? a : b;<br>    return max;<br>}</p>
<p>int main(){<br>    HelloWorld();<br>    int a &#x3D; 5;<br>    int b &#x3D; 10;<br>    int c;<br>    c &#x3D; FindMax(a, b);<br>    printf(“\n最大数为：%d\n”, c);<br>    return 0;<br>}</p>
<p>3.函数的参数<br>形参：形参出现在函数定义中，在整个函数体内都可以使用，离开该函数则不能使用。<br>实参：实参在主调函数中，是调用函数时传递的参数。<br>参数传递：函数的参数由主调函数的实参传递给被调函数的形参，因此实参与形参的顺序、类型必须保持一致。<br>4.函数的返回值<br>函数返回值是一个类型与函数声明中定义的返回类型相同的值，如果函数声明中没有定义返回类型，则默认为 int 类型。<br>例如，下面是一个简单的 C 函数，它返回一个整数值：</p>
<p>int max(int a, int b)<br>{<br>    if (a &gt; b) {<br>        return a;<br>    } else {<br>        return b;<br>    }<br>}</p>
<p>在这个例子中，函数 max() 定义了两个 int 类型的参数 a 和 b，并在函数体内部判断它们的大小关系。如果 a 大于 b，则函数返回 a 的值；否则，函数返回 b 的值。</p>
<p>另外，如果函数声明中定义了 void 类型的返回值，则表示函数不会返回任何值。在这种情况下，函数体内部不能使用 return 语句返回值。例如：</p>
<p>void print_hello()<br>{<br>    printf(“Hello, world!\n”);<br>}</p>
<p>在这个例子中，函数 print_hello() 不需要返回任何值，因此声明中定义的返回类型为 void。</p>
<p>5.函数的调用<br>调用的一般形式为：函数名(实参);<br>被调用函数的声明和函数原型：在主调函数中调用某函数之前应对该被调函数进行说明（声明），这与使用变量之前要先进行变量说明是一样的。在主调函数中对被调函数作说明的目的是使编译系统知道被调函数返回值的类型，以便在主调函数中按此种类型对返回值作相应的处理。<br>其一般形式为： 类型说明符 被调函数名(类型 形参，类型 形参…);或 类型说明符 被调函数名(类型，类型…);<br>6.全局变量与局部变量<br>作用域：表示一个变量起作用的范围，例如：</p>
<p>{<br>    int a &#x3D; 1; &#x2F;&#x2F;a的作用域就是这个代码块，在代码块外部就无法访问变量a<br>}</p>
<p>1）全局变量<br>定义：全局变量也称为外部变量，它是在函数外部定义的变量。它不属于哪一个函数，它属于一个源程序文件。其作用域是整个源程序。<br>使用：在全局变量定义之前的函数中使用全局变量，需要使用关键字extern做全局变量说明,声明某个变量是全局变量，然后才能使用；在全局变量定义之后的函数中使用全局变量，可以省略extern关键字，不做全局变量说明也可以使用。<br>int a &#x3D; 5; &#x2F;&#x2F; 此处a为全局变量</p>
<p>int main(void){<br>    int extern a; &#x2F;&#x2F; 全局变量说明，声明a是一个全局变量，此处在a定义之后，可以省略该说明<br>    printf(“%d”, a); &#x2F;&#x2F;输出结果为5<br>}</p>
<p>2）局部变量<br>定义：局部变量也称为内部变量。局部变量是函数内部定义的变量，作用域仅限于函数内部，局部变量只能在函数内部使用，函数外部无法访问。<br>int main(void){<br>    int a &#x3D; 5; &#x2F;&#x2F; 这是一个局部变量，a的作用域范围是main函数内，在函数外无法使用<br>    print(“%d”, a);<br>    a++;<br>}<br>print(“%d”, a);&#x2F;&#x2F;全局作用域内找不到变量a，编译不通过</p>
<p>7.静态变量与寄存器变量<br>1）静态变量<br>定义：静态变量是在函数调用结束后不消失而保留原值的变量，如果在一个函数调用结束后，希望它保留某个变量的值，就把这个变量用static关键字声明为静态变量。<br>&#x2F;&#x2F; 定义一个自增函数，初始化局部静态变量a为0，每调用一次，a自增1<br>int Add() {<br>    static int a &#x3D; 0;<br>    a++;<br>    return a;<br>}</p>
<p>int main(){<br>    print(“%d”, Add());&#x2F;&#x2F; 输出结果为1<br>    print(“%d”, Add());&#x2F;&#x2F; 输出结果为2<br>    return 0;<br>}</p>
<p>2）寄存器变量<br>定义：寄存器变量是放在CPU寄存器中的变量，CPU寄存器可以理解为CPU的内存空间，就像是电脑的内存一样，在寄存器中运算速度非常快。使用register关键字声明。<br>注意：<br>只有局部自动变量（非静态变量）和形参可以作为寄存器变量<br>一个计算机系统中的寄存器数目有限，不能定义任意多个寄存器变量<br>局部静态变量不能定义为寄存器变量<br>#include “stdio.h”</p>
<p>&#x2F;&#x2F; 这是一个计算n的阶乘的函数，将局部变量i和f声明为寄存器变量<br>int fac(int n) {<br>    register int i, f &#x3D; 1;<br>    for (i &#x3D; 1; i &lt;&#x3D; n; i++) {<br>        f &#x3D; f * i;<br>    }<br>    return f;<br>}</p>
<p>int main() {<br>    int i;<br>    for (i &#x3D; 0; i &lt;&#x3D; 5; i++) {<br>        printf(“%d!&#x3D;%d\n”, i, fac(i));<br>    }<br>    return 0;<br>}</p>
<p>8.预处理命令<br>预处理是指在进行编译的第一遍扫描(词法扫描和语法分析)之前所作的工作。预处理是Ｃ语言的一个重要功能，它由预处理程序负责完成。<br>Ｃ语言提供了多种预处理功能，如宏定义、文件包含、条件编译等。</p>
<p>1）宏定义<br>C语言可以使用#define定义宏（类似常量），程序在编译处理时会把源程序中所有的宏名替换成宏定义的结果。<br>宏定义是由源程序中的宏定义命令完成的。宏代换是由预处理程序自动完成的。</p>
<p>无参宏定义：#define 标识符 字符串 （“字符串”可以是常数、表达式、格式串等）<br>所有出现在源程序中的宏名都会替换成宏定义的字符串<br>例如：</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#define PI 3.1415926<br>#define M (a+a)</p>
<p>int main(void) {</p>
<p>  double a &#x3D; 1.0;<br>   double b;<br>   b &#x3D; 2<em>M + PI; &#x2F;&#x2F; 等同于2</em>(a+a) + 3.1415926<br>   printf(“%f”, b);<br>   return 0;<br>}</p>
<p>带参宏定义：#define 宏名(形参1,形参2,形参3,…形参n) 字符串 （“字符串”可以是常数、表达式、格式串等）<br>类似于定义一个匿名函数</p>
<blockquote>
<p>#include &lt;stdio.h&gt;</p>
</blockquote>
<p>#define S(x,y) x*y &#x2F;&#x2F; S表示矩形面积，x，y分别表示长宽</p>
<p>int main(void) {</p>
<p>  double a &#x3D; 3.0,b &#x3D; 4.0;<br>   double s;<br>   s &#x3D; S(a,b); &#x2F;&#x2F; 等同于a*b<br>   printf(“%f”, s);<br>   return 0;<br>}</p>
<p>2）文件包含<br>文件包含命令的功能是把指定的文件插入该命令行位置取代该命令行，从而把指定的文件和当前的源程序文件连成一个源文件。<br>文件包含的形式为：#include “文件名”或#include &lt;文件名&gt;<br>上面两种形式的区别：使用尖括号表示在包含文件目录中去查找(包含目录是由用户在设置环境时设置的)，而不在源文件目录去查找；使用双引号则表示首先在当前的源文件目录中查找，若未找到才到包含目录中去查找。</p>
<p>3）条件编译<br>预处理程序提供了条件编译的功能。可以按不同的条件去编译不同的程序部分，因而产生不同的目标代码文件。</p>
<p>条件编译有以下三种形式：</p>
<p>第一种：如果标识符已被 #define命令定义过则对程序段 1 进行编译；否则对程序段 2 进行编译。<br>#ifdef 标识符<br>    程序段 1<br>#else<br>    程序段 2<br>#endif</p>
<p>第二种：如果标识符未被#define命令定义过则对程序段 1 进行编译，否则对程序段 2 进行编译。<br>#ifndef 标识符<br>    程序段 1<br>#else<br>    程序段 2<br> #endif</p>
<p>第三种：常量表达式的值为真(非 0)，则对程序段 1 进行编译，否则对程序段 2 进行编译。<br>#if 常量表达式<br>    程序段 1<br>#else<br>    程序段 2<br>#endif</p>
<p>四、指针<br>指针是指存储单元的地址，例如定义一个变量int a &#x3D; 1;指向变量a的指针就是a在内存中的地址。</p>
<p>1.变量的指针&amp;指针变量<br>变量的指针：就是变量的内存地址。<br>指针变量：存放变量地址的变量。<br>解释：比如有个变量a，变量a的地址是p，p就是变量a的指针。现在我们再假设一个变量b，然后把p赋值给变量b，那么变量b就是一个指针变量（字面意思，存放指针的变量）。<br>1）指针变量的定义<br>类型说明符* 变量名；</p>
<p>类型说明符表示这个指针指向的变量类型，换句话说这个指针变量的值必须是一个什么类型的变量的地址</p>
<p>例如：</p>
<p>int* p1; &#x2F;&#x2F;定义一个int类型的指针变量，指向的变量类型也必须是int<br>char* p2; &#x2F;&#x2F;定义一个char类型的指针变量，指向的变量类型也必须是char<br>double* p3; &#x2F;&#x2F;定义一个double类型的指针变量，指向的变量类型也必须是double</p>
<p>2）指针的操作<br>&amp;：取地址运算符<br>&amp;变量名表示取变量的地址，就是获取变量的指针</p>
<p>int a &#x3D; 123;<br>int* p &#x3D; &a; &#x2F;&#x2F;取变量a的地址赋值给指针变量p</p>
<p>*：指针运算符（或称“间接访问” 运算符）<br>*指针变量表示取指向的变量的值</p>
<p>int a &#x3D; 123;<br>int* p &#x3D; &a; &#x2F;&#x2F;取变量a的地址赋值给指针变量p<br>printf(“%d”,<em>p); &#x2F;&#x2F;输出123，</em>p表示取a的值</p>
<p>2.数组的指针&amp;指针数组<br>1）数组的指针<br>数组的指针是指数组的首地址。<br>名词解释：一个数组是由连续的一块内存单元组成的。数组名就是这块连续内存单元的首地址,也是数组中第一个元素的地址。</p>
<p>int array[] &#x3D; {1,2,3,4,5,6};<br>int* pA &#x3D; array; &#x2F;&#x2F; 数组名就是数组的指针<br>int* pB &#x3D; &amp;array[0]; &#x2F;&#x2F; 数组的第一个元素的地址就是数组的指针</p>
<p>指针pA和指针pB是相等的</p>
<p>2）指针数组<br>一个数组的元素值为指针则是指针数组。<br>定义方式：类型说明符* 数组名[数组长度]（跟普通数组定义方式相同，唯一区别是*）</p>
<p>int main() {<br>   int a&#x3D;1,b&#x3D;2,c&#x3D;3,d&#x3D;4,e&#x3D;5;<br>   int* Int[5] &#x3D; {&amp;a,&amp;b,&amp;c,&amp;d,&amp;e}; &#x2F;&#x2F; 这是一个整型指针数组<br>   &#x2F;&#x2F; 字符串在C语言中是字符数组，所以一个字符串相当于一个字符数组，字符串本身就等于字符数组的指针（首地址）<br>   const char* String[] &#x3D; {“Test1”,”Test2”,”Test3”,”Test4”,”Test5”}; &#x2F;&#x2F; 这是一个字符型的指针数组<br>   for (int i &#x3D; 0; i &lt; 5; ++i) {<br>       printf(“%p\n”,String[i]); &#x2F;&#x2F; 这里输出的就是每个字符串的指针<br>   }<br>   return 0;</p>
<p>3.字符串的指针<br>C语言中是没有字符串类型的，C语言中的字符串都是用字符数组进行存储<br>字符串的指针就是字符数组的指针，也就是字符数组的首地址</p>
<p>C语言字符串的两种定义形式：</p>
<p>数组形式：char string[] &#x3D; {‘H’,’e’,’l’,’l’,’o’,’\0’};或char string[] &#x3D; “Hello”;<br>指针形式：char* string &#x3D; “Hello”;（等价于{‘H’,’e’,’l’,’l’,’o’,’\0’}）<br>4.函数的指针&amp;指针型函数<br>1）函数的指针<br>在Ｃ语言中，一个函数总是占用一段连续的内存区，而函数名就是该函数所占内存区的首地址（函数指针）。</p>
<p>函数指针的定义：类型说明符 (*指针变量名)(实参类型);<br>int (*p)(); &#x2F;&#x2F; 定义一个函数指针p<br>int Function(){<br>    printf(“test”);<br>}<br>p &#x3D; Function; &#x2F;&#x2F; 将Function函数的入口地址赋值给函数指针变量p</p>
<p>注意：函数指针的定义区别于变量指针</p>
<p>函数指针的调用：(*指针变量名) (实参表);<br>int FindMax(int a, int b){<br>    return a &gt; b ? a : b;<br>}</p>
<p>int main() {<br>    int (*p)(int, int) &#x3D; FindMax;<br>    int max &#x3D; p(5,10);<br>    printf(“%d”,max);</p>
<pre><code>return 0;
</code></pre>
<p>} </p>
<p>2）指针型函数<br>函数类型是指针的函数就是指针型函数（函数类型是指函数返回值的类型）<br>定义：</p>
<p>类型说明符* 函数名(参数){<br>   执行语句;<br>   return 对应类型的指针;<br>}</p>
<p>例：下面定义了指针型函数，作用是随机生成一个数组，返回数组的指针</p>
<p>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;time.h&gt;</p>
<p>int* GetNumber(){<br>    static int array[10];<br>    srand((unsigned)time(NULL));<br>    for (int i &#x3D; 0; i &lt; 10; ++i) {<br>        array[i] &#x3D; rand();<br>        printf(“%d\n”,array[i]);<br>    }<br>    return array;<br>}</p>
<p>int main() {<br>    int* p &#x3D; GetNumber();<br>    printf(“&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n”);<br>    for (int i &#x3D; 0; i &lt; 10; ++i) {<br>        printf(“%d\n”,p[i]);<br>    }</p>
<p>5.指向指针的指针<br>指向指针的指针，就是字面意思，假如有个变量a,变量a的指针用p1表示，将p1赋值给一个变量b，变量b的指针用p2表示，现在将p2赋值给一个变量c，变量c就是指向指针的指针。</p>
<p>int a &#x3D; 2333;<br>int* b &#x3D; &a;<br>int** c &#x3D; &b;</p>
<p>要访问指向指针的指针的值，要使用<strong>，如上面的指针c，访问方式为</strong>c</p>
<p>五、结构体和共用体<br>1.结构体<br>结构体跟一些面向对象的语言（Python、C#、Java）中的类概念相似，就是一组数据由多个成员数据组成，成员数据可以是基本类型或者构造类型，在使用结构体之前必须先进行定义。</p>
<p>结构体是由多个不同数据类型的成员组成的数据类型。结构体中的每个成员可以有不同的数据类型和命名。使用结构体可以将多个不同数据类型的信息组合成一个单一的逻辑单元，从而方便地进行操作。</p>
<p>1）结构体的定义<br>定义结构体关键字：struct<br>定义形式：struct 结构名 {成员数据};<br>&#x2F;&#x2F; 下面定义了一个名为Person的结构体，Person包含有一个人的姓名、年龄、性别、身高、住址信息<br>struct Person{<br>    char* name;<br>    int age;<br>    char sex;<br>    double height;<br>    char address[200];<br>};</p>
<p>2）结构体的用法<br>结构体成员变量的表示方法：结构名.变量名或(*结构指针).变量名&#x2F;(<em>结构指针)-&gt;变量名<br>struct Person{<br>    char</em> name;<br>    int age;<br>    char sex;<br>    double height;<br>    char address[200];<br>};</p>
<p>int main() {<br>    struct Person man; &#x2F;&#x2F; 结构体变量实例化<br>    struct Person woman; &#x2F;&#x2F; 结构体变量实例化<br>    struct Person* pW &#x3D; &woman; &#x2F;&#x2F; 实例化一个结构体指针变量<br>    man.name; &#x2F;&#x2F; 结构体变量直接表示<br>    man.sex;<br>    (*pW).name; &#x2F;&#x2F; 结构体指针变量表示<br>    pW-&gt;sex; &#x2F;&#x2F; 结构体指针变量表示<br>    return 0;<br>}</p>
<p>结构体变量的赋值：直接给成员变量赋值，注意数组类型不能直接赋值。<br>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;</p>
<p>&#x2F;&#x2F; 下面定义了一个名为Person的结构体，Person包含有一个人的姓名、年龄、性别、身高、住址信息<br>struct Person{<br>    char* name;<br>    int age;<br>    char sex;<br>    float height;<br>    char address[200];<br>};</p>
<p>int main() {<br>    struct Person man;<br>    struct Person woman;<br>    struct Person* pW &#x3D; &woman;<br>    man.name &#x3D; “小明”; &#x2F;&#x2F; 结构体变量赋值<br>    man.sex &#x3D; ‘M’;<br>    man.age &#x3D; 18;<br>    man.height &#x3D; 1.78f;<br>    strcpy(man.address,”四川省成都市”);<br>    (*pW).name &#x3D; “小红”; &#x2F;&#x2F; 结构体变量赋值<br>    (*pW).sex &#x3D; ‘W’;<br>    pW-&gt;age &#x3D; 19;<br>    pW-&gt;height &#x3D; 1.68f;<br>    strcpy(pW-&gt;address,”四川省绵阳市”); &#x2F;&#x2F; 数组类型不能直接赋值<br>    printf(“姓名：%s\n年龄：%d\n性别：%c\n身高：%.2fm\n地址：%s\n”,man.name,man.age,man.sex,man.height,man.address);<br>    printf(“&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n”);<br>    printf(“姓名：%s\n年龄：%d\n性别：%c\n身高：%.2fm\n地址：%s\n”,woman.name,woman.age,woman.sex,(*pW).height,pW-&gt;address);<br>    return 0;<br>}</p>
<p>2.共用体（联合体）<br>共用体是一种特殊的结构体，其所有成员共享相同的内存空间。共用体中的每个成员可以有不同的数据类型，但是它们共享相同的内存空间，因此只能同时存在一个成员的值。共用体的主要用途是在不同的数据类型之间进行类型转换或节省内存空间。</p>
<p>1）共用体的定义<br>定义结构体关键字：union<br>定义形式：union 共用体名 {成员数据};<br>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;</p>
<p>union data {<br>    int i;<br>    float f;<br>    char str[20];<br>};</p>
<p>int main() {<br>    union data mydata; &#x2F;&#x2F; 实例化一个共用体变量</p>
<pre><code>mydata.i = 10;
printf(&quot;mydata.i = %d\n&quot;, mydata.i);

mydata.f = 3.14f;
printf(&quot;mydata.f = %f\n&quot;, mydata.f);

strcpy(mydata.str, &quot;Hello&quot;);
printf(&quot;mydata.str = %s\n&quot;, mydata.str);

return 0;
</code></pre>
<p>}</p>
<p>在这个例子中，我们定义了一个名为data的共用体，包含一个整型变量i、一个浮点型变量f和一个字符数组str。在main函数中，我们定义了一个mydata的共用体变量，可以用来存储int、float或char类型的数据。</p>
<p>由于所有成员变量共享同一块内存空间，因此在设置mydata.f和mydata.str时，mydata.i的值被覆盖了。这也是共用体的一个特点：在任意时刻，只能有一个成员变量是有效的。</p>
<p>2）共用体的用法<br>主要用途：在不同的数据类型之间进行类型转换或节省内存空间。</p>
<p>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;</p>
<p>union data {<br>    int i;<br>    float f;<br>    char* s;<br>    char c;<br>};</p>
<p>int main() {<br>    union data temp; &#x2F;&#x2F; 定义一个共用体temp<br>    temp.i &#x3D; 10;<br>    printf(“temp &#x3D; %d\n”,temp.i);<br>    printf(“data中i的内存地址：%p\n”,&amp;temp.i);<br>    printf(“data中f的内存地址：%p\n”,&amp;temp.f);<br>    printf(“data中s的内存地址：%p\n”,&amp;temp.s);<br>    printf(“data中c的内存地址：%p\n”,&amp;temp.c);<br>    &#x2F;&#x2F; 可以看出共用体的所有成员指向的是同一块内存空间<br>    printf(“&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n”);<br>    temp.s &#x3D; “测试”;<br>    printf(“temp &#x3D; %s\n”,temp.s);<br>    printf(“data中i的内存地址：%p\n”,&amp;temp.i);<br>    printf(“data中f的内存地址：%p\n”,&amp;temp.f);<br>    printf(“data中s的内存地址：%p\n”,&amp;temp.s);<br>    printf(“data中c的内存地址：%p\n”,&amp;temp.c);<br>    printf(“&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n”);<br>    temp.f &#x3D; 3.14159f;<br>    printf(“temp &#x3D; %f\n”,temp.f);<br>    printf(“data中i的内存地址：%p\n”,&amp;temp.i);<br>    printf(“data中f的内存地址：%p\n”,&amp;temp.f);<br>    printf(“data中s的内存地址：%p\n”,&amp;temp.s);<br>    printf(“data中c的内存地址：%p\n”,&amp;temp.c);<br>    printf(“&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n”);</p>
<pre><code>//通过上面的例子，如果把temp看做一个没有定义类型的变量，那么他就是个可变类型的变量


return 0;
</code></pre>
<p>}</p>
<p>1</p>
<p>3.枚举<br>枚举（Enumeration）是一种自定义的数据类型，它允许定义一组命名的常量。枚举类型的变量只能赋值为枚举列表中的一个值，这些值被称为枚举常量。枚举类型是一种非常方便的方式来组织和描述常量。</p>
<p>1）枚举的定义<br>定义枚举关键字：enum<br>定义枚举的形式：enum 枚举名称 {枚举常量列表};（枚举常量的值被认为是int类型或者unsigned int类型，默认枚举变量值从0开始递增）<br>enum color {<br>    RED,<br>    GREEN,<br>    BLUE<br>};<br>&#x2F;<em>上面定义了一个三种颜色的枚举，三种枚举默认值为RED&#x3D;0，GREEN&#x3D;1，BLUE&#x3D;2</em>&#x2F;<br>&#x2F;&#x2F; 下面定义一个性别的枚举，并给枚举值进行自定义<br>enum sex {<br>    MAN &#x3D; 1,<br>    WOMAN &#x3D; 2<br>}</p>
<p>2）枚举的用法<br>枚举常用来定义一组常量选项</p>
<p>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;</p>
<p>enum week {<br>    Mon,<br>    Tue,<br>    Wed,<br>    Thu,<br>    Fri,<br>    Sat,<br>    Sun<br>};</p>
<p>int main() {<br>    enum week today;<br>    today &#x3D; Mon;<br>    switch (today) {<br>        case Mon:<br>            printf(“今天是周一”);<br>            break;<br>        case Tue:<br>            printf(“今天是周二”);<br>            break;<br>        case Wed:<br>            printf(“今天是周三”);<br>            break;<br>        case Thu:<br>            printf(“今天是周四”);<br>            break;<br>        case Fri:<br>            printf(“今天是周五”);<br>            break;<br>        case Sat:<br>            printf(“今天是周六”);<br>            break;<br>        case Sun:<br>            printf(“今天是周日”);<br>            break;<br>    }<br>    return 0;<br>}</p>
<p>4.动态内存分配<br>C语言常用的内存管理函数有四个：malloc、calloc、realloc、free<br>其中申请空间的函数是malloc、calloc；重新调整空间大小的函数是realloc；释放空间的函数是free</p>
<p>1）malloc<br>作用：用于在堆上分配指定大小的内存空间，内容随机，函数原型：void* malloc(size_t size);<br>参数：</p>
<p>size：分配空间的大小（字节）<br>返回值：分配的内存空间的首地址，分配失败返回NULL空指针<br>注意：返回值类型为void*，使用时需要转换成对应类型</p>
<p>下面是一个例子：分配一块空间存储指定个数的数字，并对数字求和</p>
<p>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;</p>
<p>int main() {<br>    int* ptr; &#x2F;&#x2F; 定义一个指针变量<br>    int n, sum &#x3D; 0; &#x2F;&#x2F; 初始化元素个数与元素总和</p>
<pre><code>printf(&quot;输入要保存的元素个数: &quot;);
scanf(&quot;%d&quot;, &amp;n);

ptr = (int*) malloc(n * sizeof(int)); // 分配一块足够存储n个int类型数字的内存空间，将指针强制转换为int类型

if(ptr == NULL) &#123;
    printf(&quot;内存空间分配失败！\n&quot;);
    exit(1);
&#125;

printf(&quot;输入保存的元素:\n&quot;);
for(int i = 0; i &lt; n; i++) &#123;
    scanf(&quot;%d&quot;, &amp;ptr[i]);
    sum += ptr[i];
&#125;

printf(&quot;所有元素累加总和为：%d\n&quot;, sum);

free(ptr);// 释放内存空间ptr

return 0;
</code></pre>
<p>}</p>
<p>2）calloc<br>作用：用于在堆上分配指定数量和大小的内存空间，内容初始化为0。<br>其函数原型为：void* calloc(size_t num, size_t size);<br>参数：</p>
<p>num：分配空间块数（需要分配多少块空间）<br>size：每块空间的大小（字节）<br>返回值：分配的内存空间的首地址，分配失败返回NULL空指针<br>注意：返回值类型为void*，使用时需要转换成对应类型</p>
<p>同样使用上面的例子：</p>
<p>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;</p>
<p>int main() {<br>    int* ptr; &#x2F;&#x2F; 定义一个指针变量<br>    int n, sum &#x3D; 0; &#x2F;&#x2F; 初始化元素个数与元素总和</p>
<pre><code>printf(&quot;输入要保存的元素个数: &quot;);
scanf(&quot;%d&quot;, &amp;n);

ptr = (int*) calloc(n, sizeof(int)); // 分配n块足够存储1个int类型数字的内存空间，将指针强制转换为int类型

if(ptr == NULL) &#123;
    printf(&quot;内存空间分配失败！\n&quot;);
    exit(1);
&#125;

printf(&quot;输入保存的元素:\n&quot;);
for(int i = 0; i &lt; n; i++) &#123;
    scanf(&quot;%d&quot;, &amp;ptr[i]);
    sum += ptr[i];
&#125;

printf(&quot;所有元素累加总和为：%d\n&quot;, sum);

free(ptr);// 释放内存空间ptr

return 0;
</code></pre>
<p>}</p>
<p>3）realloc<br>作用：用于重新分配已分配内存的大小。其函数原型为：void* realloc(void* ptr, size_t size);<br>参数：</p>
<p>ptr：原内存空间地址<br>size：重新分配内存空间大小<br>返回值：分配的内存空间的首地址，分配失败返回NULL空指针<br>注意：返回值类型为void*，使用时需要转换成对应类型</p>
<p>说明：realloc重新分配是在原地址的基础上进行调整，如果是扩大空间大小，当新的空间大小超过了原空间所能扩展的范围（比如a空间占了4个字节，现在要把a空间扩展到8个字节，而在这一块连续的内存中，第7个字节已经被分配出去了，那么这块空间最大只能是6个字节了），系统会重新找一块足够大的空间来作为新空间，然后将原本空间中的数据拷贝过来，释放原本的空间，也就是指针会进行改变，值不会发生变化；如果是缩小空间大小，就会释放原空间调整之后的内存空间。</p>
<p>同样使用上面例子做修改：</p>
<p>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;</p>
<p>int main() {<br>    int* ptr; &#x2F;&#x2F; 定义一个指针变量<br>    int n,m, sum &#x3D; 0; &#x2F;&#x2F; 初始化元素个数与元素总和</p>
<pre><code>printf(&quot;输入要保存的元素个数: &quot;);
scanf(&quot;%d&quot;, &amp;n);

ptr = (int*) calloc(n, sizeof(int)); // 分配n块足够存储1个int类型数字的内存空间，将指针强制转换为int类型

if(ptr == NULL) &#123;
    printf(&quot;内存空间分配失败！\n&quot;);
    exit(1);
&#125;

printf(&quot;输入保存的元素:\n&quot;);
for(int i = 0; i &lt; n; i++) &#123;
    scanf(&quot;%d&quot;, &amp;ptr[i]);
    sum += ptr[i];
&#125;
m = n+2;
ptr = (int*)realloc(ptr,m*sizeof(int)); // 重新分配一块足够存储m个int类型数字的内存空间
printf(&quot;输入新增的元素:\n&quot;);
for(int i = n; i &lt; m; i++) &#123;
    scanf(&quot;%d&quot;, &amp;ptr[i]);
    sum += ptr[i];
&#125;

printf(&quot;所有元素累加总和为：%d\n&quot;, sum);

free(ptr);// 释放内存空间ptr

return 0;
</code></pre>
<p>}</p>
<p>4）free<br>作用：用于释放已分配的内存空间。其函数原型为：void free(void* ptr);<br>参数：</p>
<p>ptr：需要释放的空间地址<br>返回值：没有返回值</p>
<p>5.位域<br>C语言允许在一个结构体中以位(Bit)为单位来指定其成员长度，这种以位为单位的结构体成员称为“位段”或者“位域”。位域只能是int、unsigned int、signed int类型。int默认是有符号整型（signed）。<br>位域的主要目的：节省内存空间，比如开关控制只需要0和1，那么只需要1位就能表示二进制0和1，一个字节有8位，使用位域就可以只是用一个字节中的其中1位。</p>
<p>基本定义：<br>struct 位域名称 {<br>    位域列表;<br>}</p>
<p>示例：下面定义了一个日期的结构体，包含成员变量年、月、日，年我们用四位数字表示，最多只需要14位，月我们只需要四位就能表示1-12月，我们只需要用6位便能完全表示1-31日。<br>#include &lt;stdio.h&gt;</p>
<p>struct Date{<br>    unsigned int year;<br>    unsigned int month;<br>    unsigned int day;<br>};</p>
<p>struct Date2{<br>    unsigned int year : 14;<br>    unsigned int month : 4;<br>    unsigned int day : 6;<br>};</p>
<p>int main() {<br>    printf(“Date占用字节数：%llu\n”, sizeof(struct Date));<br>    printf(“Date2占用字节数：%llu\n”, sizeof(struct Date2));<br>    return 0;<br>}</p>
<p>输出结果：</p>
<p>Date占用字节数：12<br>Date2占用字节数：4</p>
<p>从以上结果便能看出，使用位域可以节省内存空间。<br>注意：位域的位数不能超过其依附的基本类型的最大位数，例如一个unsigned int类型的成员，他有4个字节，一个字节是8位，它最大只能存储32位，位域的位数就不能超过32（不同的编译器基本类型占用空间大小不一致）</p>
<p>六、文件操作<br>1.文件的概念<br>文件是一个有序数据集，数据集的名称叫文件名。文件分为两种，一种是普通文件，比如txt文件、C语言的源程序文件、头文件等等存在于磁盘上的；另一种是设备文件，比如鼠标、键盘、显示器等等外部设备，都认为是一个文件。</p>
<p>2.文件指针<br>C语言使用一个指针变量指向一个文件，通过操作指针来操作文件。<br>文件指针的定义:FILE *变量名;</p>
<p>FILE实际上是系统定义的一个结构体，该结构体中含有文件名、文件状态、文件当前位置等信息（编写程序时不用关心FILE结构体细节）</p>
<p>文件位置指针： 文件位置指针表示的是文件中所处位置的指针（头部、当前位置、末尾等），注意跟文件指针区别开，文件指针指向的是整个文件</p>
<p>3.操作文件的函数<br>1）打开与关闭<br>fopen：打开一个文件，成功返回文件的指针，失败返回空指针NULL<br>函数原型：FILE* fopen(const char *path,const char *mode)<br>path：文件路径<br>mode：打开的模式<br>mode主要由以下6个字符组合而成：<br>r：可读（文件位置指针在文件头部，文件必须存在）<br>w：可写（文件位置指针在文件头部，文件存在则清空内容，不存在就创建）<br>a：追加写入（文件位置指针在文件尾部，文件必须存在）<br>b：二进制方式打开<br>+：可读写<br>t：文本模式（默认，可省略）<br>下面列出常用模式：<br>选项	说明<br>r	只读打开一个文本文件，只允许读数据<br>w	只写打开一个文本文件，只允许写数据<br>a	追加写入打开一个文本文件，在文件末尾写数据<br>rb	以二进制方式打开一个文件，只允许读数据<br>wb	以二进制方式打开一个文件，只允许写数据<br>fclose：关闭一个文件，成功返回0，失败返回非0<br>通常对文件操作如下：<br>#include “stdio.h”<br>#include “stdlib.h”</p>
<p>FILE *fp &#x3D; fopen(“文件名”, “打开模式”);<br>if (fp &#x3D;&#x3D; NULL) {<br>        printf(“文件打开失败！”);<br>        exit(1);<br>    }</p>
<p>&#x2F;* 要执行的文件操作 *&#x2F;</p>
<p>fclose(fp);</p>
<p>2）文件读写<br>文件结束符：EOF<br>文件写入的函数需要以写或者读写模式打开文件，文件读取的函数需要以读或者读取的模式打开文件，读取或写入操作之后，位置指针都会向后移动到读取或写入位置的末尾</p>
<p>fgetc：从文件读取一个字符<br>函数原型：int fgetc(FILE *file);<br>file：目标文件的指针<br>返回值：返回int类型的ASCII码，位置指针向后移动一个字节<br>使用方法：fgetc(文件指针);<br>fputc：向文件中写入一个字符<br>函数原型：int fputc(int c, FILE <em>file);<br>c：要写入的字符（char或者int类型ASCII码）<br>file：目标文件的指针<br>返回值：成功返回写入的字符，位置指针向后移动一个字节；失败返回EOF<br>使用方法：fputc(‘a’, 文件指针);<br>fgets：从文件读取一个字符串到字符数组中<br>函数原型：char</em> fgets(char *Buffer, int MaxCount, FILE *file );<br>Buffer：字符数组的指针<br>MaxCount：最大读取字符数<br>file：目标文件的指针<br>说明：<br>MaxCount是一个正整数，表示从文件中读出的字符串不超过 MaxCount-1个字符。在读入的最后一个字符后加上串结束标志\0。<br>在读出MaxCount-1个字符之前，如遇到了换行符或EOF，则读出结束。<br>返回值：字符数组的首地址<br>使用方法：fgets(数组首地址, 字符串最大长度, 文件指针);<br>fputs：将一个字符串写入到文件中，不包含’\0’<br>函数原型：int fputs(const char *str, FILE *file);<br>str：要写入的字符数组（字符串）的指针<br>file：目标文件的指针<br>返回值：成功返回非负整数；失败返回EOF(符号常量，其值为-1)<br>使用方法：fputs(字符串, 文件指针);<br>fread：从文件中读取一组固定大小的数据到内存空间<br>函数原型：size_t fread(void *Buffer, size_t size, size_t count, FILE *file);<br>Buffer：内存空间首地址（用来存放数据的内存空间指针）<br>size：数据块的大小<br>count：数据块的数量<br>file：目标文件的指针<br>返回值：返回成功读取的对象个数（若出现错误或到达文件末尾，则可能小于count）<br>使用方法：fread(内存空间地址, 数据块大小, 数据块数量, 文件指针);<br>fwrite：写入一组固定大小的数据到文件中<br>函数原型：size_t fwrite(const void *Buffer, size_t size, size_t count, FILE *file);<br>Buffer：要存入的数据的首地址<br>size：数据块的大小<br>count：数据块的数量<br>file：目标文件的指针<br>返回值：返回成功写入的对象个数（若出现错误或到达文件末尾，则可能小于count）<br>使用方法：fwrite(数据地址, 数据块大小, 数据块数量, 文件指针);<br>fscanf：从文件中获取指定格式的数据，跟scanf类似，输入对象换成了普通文件<br>函数原型：int fscanf(FILE *file, const char *str, [arg…]);<br>file：目标文件的指针<br>str：格式化字符串<br>[arg…]：一个或多个接收数据的地址<br>说明：fscanf遇到空格和换行时结束<br>返回值：成功返回读入的参数的个数，失败返回EOF<br>使用方法：fscanf(文件指针, 格式化字符串, 目标地址);<br>fprintf：格式化输出数据到文件，跟printf类似，输出对象换成了普通文件<br>函数原型：int fprint(FILE *file, const char *str, [arg…]);<br>file：目标文件的指针<br>str：格式化字符串<br>[arg…]：一个或多个数据<br>说明：fprintf会根据参数str字符串来转换并格式化数据，然后将结果输出到参数file指定的文件中，直到出现字符串结束(\0)为止。<br>返回值：成功返回输出的数据的个数，失败返回EOF<br>使用方法：fprintf(文件指针, 格式化字符串, 目标数据);<br>3）文件定位<br>rewind：将文件的位置指针移动到文件头部<br>函数原型：void rewind(FILE *file);<br>file：目标文件的指针<br>使用方法：rewind(文件指针);<br>fseek：将文件的位置指针从规定的起始点移动到某个位置<br>函数原型：int fseek(FILE *file, long offset, int start);<br>file：目标文件的指针<br>offset：偏移量，从起始点移动多少字节，必须是long型数据<br>start：起始点，规定三个起始点：文件首、当前位置、文件尾<br>起始点	标识符	数字表示<br>文件头部	SEEK_SET	0<br>当前位置	SEEK_CUR	1<br>文件尾部	SEEK_END	2<br>使用方法：fseek(文件指针, 偏移量, 起始点);<br>4）文件检测<br>feof：判断文件位置指针是否处于文件结束位置</p>
<p>函数原型：int feof(FILE *file);<br>file：目标文件的指针<br>返回值：文件指针处于结束位置返回非0，否则返回0<br>ferror：检查文件在用各种输入输出函数进行读写时是否出错</p>
<p>函数原型：int ferror(FILE *file);<br>file：目标文件的指针<br>返回值：未出错返回0，出错返回非0<br>clearerr：清除出错标志和文件结束标志，使它们为0值</p>
<p>函数原型：void clearerr(FILE *file);<br>file：目标文件的指针<br>5）文件操作示例<br>#include “stdio.h”<br>#include “stdlib.h”</p>
<p>struct Student {<br>    char name[20];<br>    int age;<br>    float score;<br>};</p>
<p>int main() {<br>    FILE *fp &#x3D; fopen(“test.txt”, “w+”); &#x2F;&#x2F; 以读写模式打开一个文件<br>    if (fp &#x3D;&#x3D; NULL) {<br>        printf(“文件打开失败！”);<br>        exit(1);<br>    }<br>    fputc(‘a’, fp); &#x2F;&#x2F; 向文件写入一个字符’a’<br>    rewind(fp); &#x2F;&#x2F; 将文件位置指针放到文件头部，因为我们</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/12/12/C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%AE%8C%E6%95%B4%E7%89%88/" data-id="cm4lfad4d0000p47r2na82lp2" data-title="" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2024/12/11/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">十二月 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/12/12/C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%AE%8C%E6%95%B4%E7%89%88/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/12/11/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Mr万<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>